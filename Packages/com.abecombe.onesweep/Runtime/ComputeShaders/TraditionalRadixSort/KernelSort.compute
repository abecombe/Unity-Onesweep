// This file includes code adapted from GPUSorting by Thomas Smith
// https://github.com/b0nes164/GPUSorting
// Licensed under the MIT License
// Modified by abecombe, 2025

#pragma kernel Sort

#pragma use_dxc
#pragma require wavebasic
#pragma require waveballot
#pragma multi_compile WAVE_SIZE_32 WAVE_SIZE_64
#pragma multi_compile KEY_TYPE_UINT KEY_TYPE_INT KEY_TYPE_FLOAT
#pragma multi_compile SORTING_ORDER_ASCENDING SORTING_ORDER_DESCENDING
#pragma multi_compile USE_DIRECT_DISPATCH USE_INDIRECT_DISPATCH
#pragma multi_compile KEY_ONLY KEY_PAYLOAD

#include "../RadixCommon/RadixMain.hlsl"
#include "../RadixCommon/DispatchUtils.hlsl"

StructuredBuffer<uint> scanned_bucket_count_buffer; // size: RADIX_BASE * group_count
StructuredBuffer<uint> scanned_total_bucket_count_buffer; // size: RADIX_BASE

/**
 * \brief Calculates and stores this group's base scatter offset for a given bucket into shared memory.
 */
inline void LoadScannedBucketCount(uint bucket_id, uint group_id, uint group_count)
{
    // subtract the first index of bucket_id in the group
    // to make it easier to calculate the final destination of individual data
    group_shared[bucket_id] = scanned_total_bucket_count_buffer[bucket_id] + scanned_bucket_count_buffer[bucket_id * group_count + group_id] - group_shared[bucket_id];
}

/**
 * \brief Performs the final scatter phase of a traditional radix sort pass, rearranging keys (and associated payloads) into their partially-sorted positions.
 *
 * \note Dispatch group size: ceil(sort_item_count / ITEMS_PER_GROUP)
 *
 * This kernel serves as the primary data movement stage within each pass of a traditional multi-pass radix sort.
 * It leverages pre-calculated global offset information, typically generated by preceding `Count` and `Scan` kernels,
 * to correctly place items. Within each thread group, a segment of keys (and payloads, if applicable) is
 * loaded from global memory into shared memory. These items then undergo a local sort based on the
 * current radix digit, which itself involves local counting and scanning operations within the group.
 *
 * Following the local sort, each thread computes the final destination address for its items in the
 * global output buffer. This calculation uses the previously determined global bucket offsets stored in
 * buffers like `scanned_bucket_count_buffer` (for within-bucket offsets) and `scanned_total_bucket_count_buffer`
 * (for global bucket starting positions). Finally, the locally sorted keys (and payloads) are
 * scattered from shared memory to their respective, correctly permuted positions in the global output buffers,
 * reflecting the sort order for the current digit.
 */
[numthreads(THREADS_PER_GROUP, 1, 1)]
void Sort(uint group_id : SV_GroupID, uint group_thread_id : SV_GroupThreadID)
{
#if defined(USE_INDIRECT_DISPATCH)
    uint sort_count;
    uint group_count;
    get_sort_count_group_count(sort_count, group_count);
#endif

    const ItemsArray keys = LoadKeys(group_thread_id, group_id, sort_count, group_count);
    ItemsArray16bit offsets = ComputeWaveLevelLocalOffsets(group_thread_id, keys);
    GroupMemoryBarrierWithGroupSync();

    const uint bucket_total_count_in_group = ExclusiveScanBucketCountsInGroup(group_thread_id);
    GroupMemoryBarrierWithGroupSync();

    ScanBucketTotalCountExclusiveToSharedMemory(group_thread_id, bucket_total_count_in_group);
    GroupMemoryBarrierWithGroupSync();
    UpdateLocalOffsetsFromWaveToGroupLevel(group_thread_id, keys, offsets);
    GroupMemoryBarrierWithGroupSync();

    SortKeysInGroup(offsets, keys);

    LoadScannedBucketCount(group_thread_id, group_id, group_count);
    GroupMemoryBarrierWithGroupSync();

#if defined(KEY_ONLY)
    StoreKeys(group_thread_id, group_id, sort_count, group_count);
#elif defined(KEY_PAYLOAD)
    const ItemsArray out_buffer_indices = StoreKeys(group_thread_id, group_id, sort_count, group_count);
    GroupMemoryBarrierWithGroupSync();
    WriteSortedPayloadsToSharedMemory(group_thread_id, group_id, sort_count, group_count, offsets);
    GroupMemoryBarrierWithGroupSync();
    StorePayloads(group_thread_id, group_id, sort_count, group_count, out_buffer_indices);
#endif
}